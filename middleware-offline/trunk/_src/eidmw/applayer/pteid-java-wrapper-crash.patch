Index: MiscUtil.h
===================================================================
--- MiscUtil.h	(revision 2631)
+++ MiscUtil.h	(working copy)
@@ -40,7 +40,6 @@
 int Truncate(const char *path);
 //Charset conversion
 void latin1_to_utf8(unsigned char * in, unsigned char *out);
-char * utf8_to_latin1(char * in);
 
 //Common type between 2/3 different cpp files
 typedef struct _hashed_file_
Index: XadesSignature.cpp
===================================================================
--- XadesSignature.cpp	(revision 2631)
+++ XadesSignature.cpp	(working copy)
@@ -96,7 +96,6 @@
 	CByteArray XadesSignature::mp_timestamp_data = CByteArray();
 
 	CByteArray XadesSignature::mp_validate_data = CByteArray();
-	CByteArray XadesSignature::mp_subject_name = CByteArray();
 
 	CByteArray XadesSignature::HashFile(const char *file_path)
 	{
@@ -588,7 +587,7 @@
 }
 
 /*
- * A little HTML-scraping to get the validation result and timestamp value
+ * A little HTML-scraping to get the validation result
  */
 bool XadesSignature::grep_validation_result (char *time_and_date)
 {
@@ -597,7 +596,6 @@
 	const char * valid_timestamp_pattern = "Selo Temporal V\xE1lido.";
 	const char * invalid_timestamp_pattern = "Selo Temporal n\xE3o corresponde ao ficheiro seleccionado";
 	const char * general_error_pattern = "Ocorreu um erro";
-	const char * signed_by = getString(16);
 	unsigned char *haystack = mp_validate_data.GetBytes();
 
 	if (mp_validate_data.Size() == 0)
@@ -608,14 +606,11 @@
 	
 	const char *ts_str = strstr((const char *)haystack, valid_timestamp_pattern);
 
-	//Warning: magic offsets ahead...
 	if (ts_str != NULL)
 	{
 		//Grab the TimeDate string
-		strcat(time_and_date, signed_by);
-		strncpy(time_and_date+strlen(signed_by), ts_str+36, 27);
-		time_and_date[27+strlen(signed_by)] = '\n';
-		time_and_date[28+strlen(signed_by)] = 0;
+		strncpy(time_and_date, ts_str+36, 27);
+		time_and_date[27] = 0;
 
 		return true; 
 	}
@@ -954,25 +949,7 @@
 
 }
 
-char * XadesSignature::parseSubjectFromCert(const char *cert_buffer)
-{
 
-	//Subject name
-	X509 *cert;
-	const int BUFSIZE = 500;
-
-	if ((cert = loadCertFromPEM(cert_buffer)) == NULL)
-		return NULL;
-
-	char *subject = (char *)malloc(BUFSIZE*sizeof(unsigned char));
-
-	X509_NAME_get_text_by_NID(X509_get_subject_name(cert), NID_commonName, subject, BUFSIZE);
-
-	return subject;
-
-}
-
-
 bool XadesSignature::ValidateXades(CByteArray signature, tHashedFile **hashes, char *errors, unsigned long *error_length)
 {
 	bool errorsOccured = false;
@@ -1088,19 +1065,6 @@
 				DSIGKeyInfoX509 *cert_element = dynamic_cast<DSIGKeyInfoX509 *> (keyinfo);
 				const XMLCh *pem_cert = cert_element->getCertificateItem(0);
 				char * tmp_cert = XMLString::transcode(pem_cert);
-				
-				//Clear the static array
-				mp_subject_name.Chop(mp_subject_name.Size());
-				//Parse the signer's name from the certificate
-				char * subject_name = utf8_to_latin1(
-					   parseSubjectFromCert(tmp_cert));
-
-				if (subject_name != NULL)
-				{
-					mp_subject_name.Append(CONST_STR getString(14), strlen(getString(14)));
-					mp_subject_name.Append(CONST_STR " ", 1);
-					mp_subject_name.Append(CONST_STR subject_name, strlen(subject_name));
-				}
 				bool cert_result = ValidateCert(tmp_cert);
 
 				if (!cert_result)
@@ -1109,10 +1073,6 @@
 					*error_length = err_len;
 					return false;
 				}
-				
-					
-
-				
 				XMLString::release(&tmp_cert);
 			}
 		}
Index: MiscUtil.cpp
===================================================================
--- MiscUtil.cpp	(revision 2631)
+++ MiscUtil.cpp	(working copy)
@@ -35,7 +35,6 @@
 #include <sys/stat.h>
 #ifndef WIN32
 #include <unistd.h>
-#include <iconv.h>
 #endif
 #include <errno.h>
 
@@ -105,131 +104,6 @@
 		*out = '\0';
 	}
 
-#ifdef WIN32
-//TODO: Needs testing...
-	char * utf8_to_latin1(char * in)
-	{
-		char* ansi = NULL;
-		int length = MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)in, -1, NULL, 0);
-		if (length > 0)
-		{
-			wchar_t* wide = new wchar_t[length];
-			MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)in, -1, wide, length);
-
-			// convert it to ANSI, use setlocale() to set your locale, if not set
-			size_t convertedChars = 0;
-			ansi = new char[length];
-			wcstombs_s(&convertedChars, ansi, length, wide, _TRUNCATE);
-		}
-		return ansi;
-
-	}
-#else
-
-const char * OUTSET = "WINDOWS-1252";
-const char * INSET = "UTF-8";
-
-/* Iconv Wrapper for UNIX */
-
-iconv_t
-iconv_init(void)
-{
-    iconv_t conv_desc;
-    conv_desc = iconv_open (OUTSET, INSET);
-    if (conv_desc == (iconv_t)-1) {
-	/* Initialization failure. */
-	if (errno == EINVAL) {
-	    fprintf (stderr,
-		     "Conversion from '%s' to '%s' is not supported.\n",
-		     INSET, OUTSET);
-	} else {
-	    fprintf (stderr, "Initialization failure: %s\n",
-		     strerror (errno));
-	}
-    }
-    return conv_desc;
-}
-
-
-/* Convert UTF-8 into LATIN-1 using the iconv library. */
-
-char *
-utf82latin1(iconv_t conv_desc, char * euc)
-{
-    size_t iconv_value;
-    char * utf8;
-    size_t len;
-    size_t utf8len;
-    /* The variables with "start" in their name are solely for display
-       of what the function is doing. As iconv runs, it alters the
-       values of the variables, so these are for keeping track of the
-       start points and start lengths. */
-    char * utf8start;
-    const char * euc_start;
-    int len_start;
-    int utf8len_start;
-
-    len = strlen (euc);
-    if (!len) {
-	fprintf (stderr, "Input string is empty.\n");
-	return (0);
-    }
-    /* Assign enough space to put the Latin1. */
-    utf8len = len;
-    utf8 = (char *)calloc (utf8len, 1);
-    /* Keep track of the variables. */
-    len_start = len;
-    utf8len_start = utf8len;
-    utf8start = utf8;
-    euc_start = euc;
-    iconv_value = iconv (conv_desc, & euc, & len, & utf8, & utf8len);
-    /* Handle failures. */
-    if (iconv_value == (size_t) -1) {
-	fprintf (stderr, "iconv failed: in string '%s', length %d, "
-		"out string '%s', length %d\n",
-		 euc, (int)len, utf8start, (int)utf8len);
-	switch (errno) {
-	    /* See "man 3 iconv" for an explanation. */
-	case EILSEQ:
-	    fprintf (stderr, "Invalid multibyte sequence.\n");
-	    break;
-	case EINVAL:
-	    fprintf (stderr, "Incomplete multibyte sequence.\n");
-	    break;
-	case E2BIG:
-	    fprintf (stderr, "No more room.\n");
-	    break;
-	default:
-	    fprintf (stderr, "Error: %s.\n", strerror (errno));
-	}
-    }
-    return utf8start;
-}
-
-/* Close the connection with the library. */
-
-void
-iconv_finalize (iconv_t conv_desc)
-{
-    int v;
-    v = iconv_close (conv_desc);
-    if (v != 0) {
-	fprintf (stderr, "iconv_close failed: %s\n", strerror (errno));
-    }
-}
-char * utf8_to_latin1(char * in)
-{
-	iconv_t conv_desc;
-	conv_desc = iconv_init();
-	char *out_string = utf82latin1(conv_desc, in);
-	iconv_finalize (conv_desc);
-
-	return out_string;
-
-}
-
-#endif
-
 /*****************************************************************************************
 ------------------------------------ CTimestampUtil ---------------------------------------
 *****************************************************************************************/
Index: APLCard.cpp
===================================================================
--- APLCard.cpp	(revision 2631)
+++ APLCard.cpp	(working copy)
@@ -294,16 +294,11 @@
 	{
 	   if (timestamp.Size() > 0)
 		   result &= XadesSignature::ValidateTimestamp(sig_content, timestamp, errors, error_len);
+	   else
+	     //This indicates that we don't have any timestamp string piggybacked on the *errors* parameter
+		 *error_len = 0;
 	}
-	unsigned long subject_len = XadesSignature::mp_subject_name.Size();
-	
-	if (errors[*error_len-1] != '\n')
-		strcat(errors, "\n");
 
-	if (subject_len > 0)
-	  strncat(errors, (const char*)XadesSignature::mp_subject_name.GetBytes(),
-	    subject_len);
-
 	return result;
 
 }
Index: XadesSignature.h
===================================================================
--- XadesSignature.h	(revision 2631)
+++ XadesSignature.h	(working copy)
@@ -18,8 +18,6 @@
 
 #define XERCES_NS XERCES_CPP_NAMESPACE_QUALIFIER
 
-#define CONST_STR (const unsigned char *)
-
 #ifndef WIN32
 #define _strdup strdup
 #endif
@@ -53,11 +51,7 @@
 		"Validation error: RSA Signature of referenced content is invalid",
 		"Erro de validação da assinatura: A assinatura criptográfica do conteúdo está inválida",
 		"Validation Error: The certificate used to sign this data is not trusted",
-		"Erro de validação da assinatura: O certificado contido na assinatura não provém de uma fonte confiável",
-		"Signed by:",
-		"Assinado por:",
-		"Timestamp: ",
-		"Selo temporal: "
+		"Erro de validação da assinatura: O certificado contido na assinatura não provém de uma fonte confiável"
 	};
 
 	class XadesSignature
@@ -87,7 +81,6 @@
 
 		static CByteArray mp_timestamp_data;
 		static CByteArray mp_validate_data;
-		static CByteArray mp_subject_name;
 		static void do_post_validate_timestamp(char *input, long input_len, char *sha1_string);
 
 		private:
@@ -95,7 +88,6 @@
 		std::string getTS_CAPath();
 		
 		CByteArray HashFile(const char *file_path);
-		static char * parseSubjectFromCert(const char *cert);
 		DOMNode * addSignatureProperties(DSIGSignature *sig);
 		CByteArray *WriteToByteArray(XERCES_NS DOMDocument *doc); 
 		//Utility methods for signature
@@ -130,7 +122,7 @@
 		{
 			
 			std::wstring language = CConfig::GetString(CConfig::EIDMW_CONFIG_PARAM_GENERAL_LANGUAGE);
-			if(wcscmp(L"nl", language.c_str())==0)
+			if(wcscmp(L"nl", language.c_str())==0)
 			{
 				return XADES_STRINGS[id+1];
 			}
